---Title: Just the Smalltalk Syntax script---#Just the Smalltalk Syntax script- BlGlutinHostSpace zoomFactor: 1.5- #Script##Intro###Title*Hello. My name is Oscar Nierstrasz. Today I'd like to give you quick guided tour of the syntax of Smalltalk.* ###Postcard*Smalltalk syntax is quite compact, and famously fits on a postcard.* ###Read aloud*Smalltalk syntax is designed so that you can read it aloud, and it should make sense.* *For example:* `Smalltalk allClasses select: #isAbstract`  *returns all the abstract classes in the Smalltalk system.* #Literals*Let's start with syntax for all kinds of literal values.* ##Integers, Floats and Radix numbers*As you would expect, Smalltalk not only supports integers**and various kinds of floats,**but also radix numbers with an explicit base. Here we see the number 42 in binary, octal and hex.* ##Strings*Strings in Smalltalk are surrounded by single quotes.* *Type two of them to get a single quote within a string.* #Characters*Typeable characters start with a dollar sign. This is the letter* `a` .*Just ask the Character class for a non-typeable character such as a tab or a newline.*  #Symbols*A symbol is a sequence of a characters starting with a hash. Symbols are pretty much like strings, except that they are unique. You can have many strings with the same value, but only one symbol.* #Literal arrays*A literal array starts with a hash, followed by matching parentheses enclosing any sequence of literal values.* *Literal arrays can be nested.* ##Byte arrays*A byte array is similar but uses square brackets, and can only contain 8-bit integers.* ##Reserved words*Pharo Smalltalk has just six reserved keywords, whose meanings should be obvious, except for* `thisContext`*, which is used in metaprogramming to access the run-time stack.* ##Expressions*Expressions in Smalltalk are formed by sending messages to objects.**There are three kinds of messages: unary, binary, and keyword.* ##Unary messages`3 factorial` *is a unary message. It sends the message* `factorial` *to the object* `3`. ##Binary messages*Binary messages consist of operators like plus or minus, followed by a single argument.* `3+4` *sends the message* `+` *to the object* `3` *with the argument* `4`.##Keyword messages*Finally, keyword messages consist of a number of keywords, each followed by a colon and an argument.* `'Hello world' copyReplaceAll: 'world' with: 'folks'` *sends the message* `#copyReplaceAll:with:` *to the string* `'Hello world'` *with the two arguments* `'world'` *and* `'folks'` ##Precedence*Within a complex expression, first unary messages are evaluated, left to right, then binary messages, and last of all, keyword messages.* `2 raisedTo: 1 + 3 factorial ` *is the same as the second expression here with parentheses.* ##Cascades*Cascades are used to send a sequence of messages, separated by semi-colons, to the same receiver object.* *Here we send three* `add:` *messages to a new* `OrderedCollection`, *followed by a* `reversed` *message. The result is a reversed collection.* ##Dynamic arrays*Lastly, a dynamic array consists of arbitrary expressions in curly braces separated by periods.* *Don't confuse literal and dynamic arrays! A literal array treats every token inside it as a literal, not an expression.* ##Statements*Statements in Smalltalk are expressions separated by periods.**We can also declare temporary variables, such as* `a`, `b` *and* `c` *here, and assign values of expressions to them.* ##Blocks*A block closure is a snippet of code within square brackets. It's essentially a lambda, or an anonymous function.* *You can evaluate a block by sending it the message* `value`. *The value returned is that of the last statement in the block, in this case, the value of* `3+4`.##Blocks with arguments*A block can take arguments, which are declared at the beginning of the block with a colon, followed by an or-bar.*  *This block increments its argument. We evaluate it by sending the message* `value:` *with an argument.* ##Blocks with multiple arguments*This block has two arguments,* `a` *and* `b`*, and a temporary variable,* `c`. *To evaluate it, we send it* `value:value:` *with two arguments.* *As you might guess, this generalizes to yet more arguments.* ##Control constructs*Interestingly, Smalltalk has no syntax for control constructs,  but instead implements them as messages to objects.* *Here we ask if there are fewer than 1000 classes in the system, and then we send that boolean object the message* `#ifTrue:ifFalse`*. If it's true, we get one string back, else the other.* ##Classes and Methods##Creating classes*There is also no syntax for defining classes. Here we send a message to the class* `Object`*, asking it to create the* `HelloWorld` *subclass for us.* *Of course we can also create classes using the coding tools.* *Class names start with an upper-case letter, and are globally visible.* ##Methods##Defining methods*Methods can be defined programmatically, just like classes, or using the IDE. Now we'll create one as a fixit.*  *In this snippet we see a monkey wrench icon next to the* `hello` *message, indicating that there is no* `hello` *method implemented yet. We can click on the icon to fix it.* *Every method starts with a declaration of the message and any arguments. In this case it's just* `hello` *with no arguments.* *Methods often start with a brief comment in double quotes. Note that a comment is not a value in Smalltalk, unlike a string.* *We return a value using the caret symbol. Here we just return the* `'Hello world'` *string.* ##Defining keyword methods*We can similarly declare methods for keyword messages.* *In this case the method name, or "selector", is* `hello:`*, and there is a formal parameter,* `aString`.##Pragmas*Pragmas are annotations in angle brackets. The *`<gtExample>`* pragma informs GT that this method contains test code and returns an example object.* *As in blocks, we must declare any temporary variables within or-bars before any executable code. We assign the values of expressions to variables with the *`:=`* operator. And statements are separated by periods.* *In GT we can directly evaluate and inspect the example.* ##Conclusion*Finally we can browse through the postcard example and see how it demonstrates all the syntactic constructs of Pharo Smalltalk.**We have unary messages, such as* `isNil` *and* `size`,*binary messages like* `&`, `+` *and* `<`,*and keyword messages, such as* `do:` *and* `show:`.*There are temporaries, like* `y`, `byteArray` *and* `var`,*an argument,* `x`,*globals* `Transcript` *and* `Character`.*We use* `self`, `super` *and* `thisContext`, *we have both dynamic and literal arrays, integers, floats, characters, and so on.* *You'll find more GT in 7' videos on our YouTube channel, or you can explore GT by downloading it from gtoolkit.com.**Thanks for listening.*