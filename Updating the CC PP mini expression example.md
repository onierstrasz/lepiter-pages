---Title: Updating the CC PP mini expression example---#Updating the CC PP mini expression example- [[todo]]- Updating the PP1 mini example to PP2.- #Scripted mini expression example    - We have to temporarily define recursive parsers as {{gtClass:name=PP2UnresolvedNode}} instances to resolve the rcursion.    - mul := PP2UnresolvedNode new.add := PP2UnresolvedNode new.prim := PP2UnresolvedNode new.dec := #digit asPParser.add def: (mul , $+ asPParser , add) / mul.mul def: (prim , $* asPParser , mul) / prim.prim def: ($( asPParser , add , $) asPParser) / dec.goal := add end.goal parse: '6*(3+4)'- #Class extraction    - Now that the rules are all defined, we can remove the references to {{gtClass:name=PP2UnresolvedNode}}.    - dec := #digit asPParser.add := (mul , $+ asPParser , add) / mul.mul := (prim , $* asPParser , mul) / prim.prim := ($( asPParser , add , $) asPParser) / dec.goal := add end.    - We extract the class on a copy.    - goal := SimpleExpressionParser new    - We check that {{gtClass:name=SimpleExpressionParser}}works.    - SimpleExpressionParser parse: '6*(3+4)'- # Defining the Interpreter with rules    - We can first protype the interpreter.    - mul := PP2UnresolvedNode new.add := PP2UnresolvedNode new.prim := PP2UnresolvedNode new.dec := #digit asPParser ==> [ :node | node asString asNumber ].add def: 	((mul , $+ asPParser , add)		==> [ :node | node first + node third ])	/ mul.mul def: 	((prim , $* asPParser , mul) 		==> [ :node | node first * node third ]) 	/ prim.prim def: 	(($( asPParser , add , $) asPParser) 		==> [ :node | node second ]) 	/ dec.goal := add end.goal parse: '6*(3+4)'- #Defining the interpreter as a subclass    - We can also directly define a subclass of {{gtClass:name=SimpleExpressionParser}} called {{gtClass:name=SimpleExpressionInterpreter}}.    - We can generate sub methods by metaprogramming.    - (SimpleExpressionParser methods collect: #selector)	do: [ :each | SimpleExpressionInterpreter compile: each , ' ^ super ' , each ].    - Now we either need to split the rules into parts so the subclass can add actions to the subparts, or we can test whether the node is a value to decide what to do next. We opt for the latter. For example: {{gtMethod:name=SimpleExpressionInterpreter>>#add|expanded}}    - We verify that it works.    - SimpleExpressionInterpreter parse: '6*(3+4)'