---Title: How to incrementally collect results of tasks---#How to incrementally collect results of tasks- [[todo]] [[randomnote]] [[howto]]- See [[2022-11-28 TG sync on workflow evolution futures]]- See also [[Create a tutorial on Streams, Futures and Promises]]- #Repo    - Metacello new	baseline: 'GtDemos';	repository: 'github://onierstrasz/gt-demos/src';	load.(Smalltalk at: #BaselineOfGtDemos) loadLepiter.Smalltalk saveAs: 'gt-demos'- #Problem    - I want to have a view of the results of a series of tasks (eg computing workflow commits) that take varying times, so the first ones done should appear first.    - Can we use futures or promises? It seems not, since ASyncStreams are always ordered. They are not yet designed for such a use case.    - Instead we can program it as below with plain Smalltalk processes.- #Slow Algorithm    - The problem with simulating slow  processes with delays is that they yield the processor.    - Instead we need actually expensive test processes.    - Random sort.    - randomSort := [ :n | 	list := (1 to: n) reversed.	[ list isSorted ] whileFalse: [ list := list shuffled ] ].[ randomSort value: 10 ] timeToRun    - A random sort of size 11 takes about 20 seconds. Of size 9 less than a second. Size 10 3-4 seconds, and up to 10.    - Random sort of size 9 takes less than a second, size 10, 3-10 seconds, size 11 about 20-130 seconds, size 12 is very very slow.    - Displaying the results.    - Note that this only works if we fork at a lower priority than the user background priority.    - tasks := (1 to: 100)		collect: [ :max | 			[ | budget lastTime list iterations |			budget := 1 milliseconds.			lastTime := Time now asDuration.			iterations := 0.			list := (1 to: 9) reversed.			[ list isSorted ]				whileFalse: [ list := list shuffled.					iterations := iterations + 1.					Time now asDuration - lastTime > budget						ifTrue: [ Processor yield.							lastTime := Time now asDuration ] ].			iterations ] ].result := OrderedCollection new asValueHolder.mutex := Semaphore forMutualExclusion.processes := OrderedCollection new.tasks	do: [ :task | 		processes			add: ([ | value |				value := task value.				mutex critical: [ result addLast: value ] ]					forkAt: Processor userBackgroundPriority - 1) ].result    - processes do: #terminate- #Async futures    - [ 3 + 4 ] asAsyncFuture wait    - How to view a stream of futures?    - randomSort := [ :n | 	list := (1 to: n) reversed.	[ list isSorted ] whileFalse: [ list := list shuffled ].	n ].future := [ randomSort value: 10 ] asAsyncFuture await    - The gt filters make use of {{gtClass:name=GtPharoStreamingMethodsCoderElement}}, which seems complicated. Is there an easier way just using one of the AsyncStream classes?    ```{{gtExample:AsyncStreamExamples >> #allTypesOfStreams | noCode=true}}```    - See the {{gtPackage:name=Futures-Examples}} package.    - (1 to: 20)	collect: [ :each | 		| delay |		delay := each atRandom.		[ delay milliseconds asDelay wait.		delay ] asAsyncFuture wait ]    - This delays too much    - (1 to: 10) collect: [ :each | [ randomSort value: 9 ] asAsyncFuture await ]- #Slack chat    - We need addLast: to be thread-safe.    - result := OrderedCollection new asValueHolder.mutex := Semaphore forMutualExclusion.1	to: 10	do: [ :each | 		| delay |		delay := each atRandom.		[ delay seconds asDelay wait.		mutex critical: [ result addLast: delay ] ] fork ].result- #Yielding    - The problem with this example is that the `Processor yield` is redundant for a process that does a delay.    - If the tasks are long-lived, they have to be nice to each other by measuring the time spent, like this:    - tasks := (1 to: 20)		collect: [ :max | 			[ | total budget lastTime |			budget := 1 milliseconds.			lastTime := Time now asDuration.			total := 0.			1				to: max				do: [ :n | 					| delay |					Time now asDuration - lastTime > budget						ifTrue: [ Processor yield.							lastTime := Time now asDuration ].					delay := (100 * n) atRandom.					total := total + delay.					(Delay forMilliseconds: delay) wait ].			total ] ].result := OrderedCollection new asValueHolder.mutex := Semaphore forMutualExclusion.processes := OrderedCollection new.tasks	do: [ :task | 		processes			add: [ | value |				value := task value.				mutex critical: [ result addLast: value ] ] fork ].result    - We can terminate the processes if needed.    - processes do: #terminate