---Title: How to rename classes and methods programmatically---#How to rename classes and methods programmatically- [[howto]]- **Caveat:** [[DR]] says that there are numerous `RB*` classes that have been modified for Pharo but do not work in GT.- #Renaming classes    - See    - RBRenameClassRefactoring comment    - Object subclass: #Dummy    - (Smalltalk globals includesKey: #Dummy)	& (Smalltalk globals includesKey: #FooBar) not    - (RBRenameClassRefactoring rename: 'Dummy' to: 'FooBar') execute    - (Smalltalk globals includesKey: #Dummy) not	& (Smalltalk globals includesKey: #FooBar)- # Renaming methods    - How to rename methods within a given package only?    - [[JB]] says to do it this way:    - packageName := SPL package name asSymbol.oldSelector := #stepIn:.newSelector := #stepInContext:.permutation := 1 to: oldSelector numArgs.classes := ((oldSelector gtSenders | oldSelector gtImplementors)		& packageName gtPackageMatches) contents collect: #methodClass.aClass := classes first.refactoring := RBRenameMethodRefactoring		model: (RBNamespace				onEnvironment: (RBPackageEnvironment packageName: packageName))		renameMethod: oldSelector		in: aClass		to: newSelector		permutation: permutation.refactoring	primitiveExecute;	model    - If classes from other packages are extended, they can be picked up too. If you don't want that, you can explicitly list the classes as Follows:    - packageName := SPL package name asSymbol.oldSelector := #stepIn:.newSelector := #stepInContext:.permutation := 1 to: oldSelector numArgs.classes := (#stepIn: gtSenders | #stepIn: gtImplementors		& SPL package name gtPackageMatches) contents collect: #methodClass.aClass := classes first.refactoring := RBRenameMethodRefactoring		model: (RBNamespace				onEnvironment: (RBPackageEnvironment packageName: packageName))		renameMethod: oldSelector		in: aClass		to: newSelector		permutation: permutation.refactoring	primitiveExecute;	model