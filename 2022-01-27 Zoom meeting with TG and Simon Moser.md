---Title: 2022-01-27 Zoom meeting with TG and Simon Moser---#2022-01-27 Zoom meeting with TG and Simon Moser- [[meetings]] [[randomnote]] on Zoom meeting of 2022-01-27.- Simon is interested in how to turn a prototype into an product.- Feenk is all about how to understand and explain systems.- Currently reverse engineering a huge heterogeneous legacy software system.- Tools exist to analyze eg Java systems, but how many of these tools actually help you make decisions? In reality most systems are not just in one language (like Java), and what's interesting about it not just the language. There are various frameworks and many other pieces of technology at play. More important than the technology is the *domain*.- Any "clicking" tool is almost guaranteed to be useless, because it hard-codes the problem in the click. In reality every problem is different. You need to create the tool after you understand the problem, or even as part of the process of understanding the problem.- Example of [analyzing a system with many feature toggles](https://lepiter.io/feenk/steering-agile-architecture-by-example--th-e2p6aps2brbby94deek31xqxh/).- The client wanted to document the feature toggles, but they did not know which one needed documenting.- Incrementally built models and visualizations to understand which features were used by which applications. Can navigate from the visualization to the model entities.- Can embed the live visualizations into documents.- New feedback loops enable new ways of running your business. Automated testing and devops are not interesting from the technicalpoint of view, but because they allow you to make business decisions more quickly.- Moldable development is based on the idea that *tools become code*. Tools can be embedded in documents, and can be adapted to new problems. If you don't have the tool that you need, then you should be able to quickly *mold* it. See the {{gtPage:Moldable Development show|db=2j9m7db2i4oz116bexd7wbdxo}}.- SM: So this a toolkit that allows you to model and see the current reality. It isn't intended to model where you want to go and how you will get there. You can't use it to allocate and track resources?- TG: We can use the model to pose queries and identify issues to be solved. We can then turn these queries into constraints that indicate where we want to go, and drive the work.- Another example is the restaurant management system. The market is highly fragmented because no one system covers the whole context.- The biggest problem in restaurants is to get access to information. For example, a waiter often has to ask customers if they got an item they ordered.- Powerpoints, whiteboards and drawings are useful for brainstorming about the future system. When you want to reason about the current system, you want a live model.- You can then create a live model to describe what you want to build. (A domain modeling exercise.)- You can both build a DSL to model various scenarios, and have custom views to visualize and explore the model. Now the diagram that was on a whiteboard becomes a live simulation as well as a live document.- You only talk about the future system at moment zero. Afterward you always have a system that is evolving.- SM: But that is a model. Where is the real system? What if the system is to be built with other technology?- TG: You can either build the system in Smalltalk, or you can synchronize the model with the system built in another language.- Final example: how to deal with an arbitrary API? Working with a rest API. Pull the data from outside the system and build an explorable model within GT.- SM is working with SBB on a warning system to infrom workers when a train is approaches. Currently two subsystems: a UI built with Java, and safety-certified components programmed in C++. Want to market this to other customers than SBB. How to do it? Currently very much customized for SBB.